#+ORG2BLOG:
#+DATE: [2024-03-17 dom 09:22]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil
#+CATEGORY: Language learning
#+TAGS: Rust
#+DESCRIPTION: adding some fruits in a rust binary tree
#+TITLE: Growing a (sorting) tree
* Adding some fruit to our tree
In a previous post *Growing a (binary) tree* I described what a binary tree is
and how to create one in Rust.

To really have an useful tree we may want to add some content to the data structure.
let's start with something simple: each node can host a 32 bit integer
#+begin_src rust
#[derive(Debug)]
pub struct BTree0 {
    pub left : Option<Box<BTree0>>,
    pub right : Option<Box<BTree0>>,
    pub content : i32,
}
#+end_src

Trees are often built with a recursive function call, i.e. a function which
calls itself. Of course there should be some way to limit this calls in order to
avoid infinite loops. Let's start with a function which accepts two values:
- a maximum possible depth of our tree
- the current depth of the tree itself.
The level of each node will be stored in the node content.
#+begin_src rust
fn main() {
    let test = add_level(1, 4);
    println!("Hello, world! {:?}", test);
}

fn add_level(current_level : i32, max_level : i32) -> BTree0 {
    // this expression is the value returned by this function
    BTree0 {
        left: (
            // also if blocks can return a value
            if current_level < max_level{
                // each call increases the current level until the maximum
                Some(Box::new(add_level(current_level + 1, max_level)))
            } else {
               None
            }
        ),
        right: (
            if current_level < max_level{
                Some(Box::new(add_level(current_level + 1, max_level)))
            } else {
               None
            }
        ),
        content: current_level
    }
}
#+end_src

In this code you can see an interesting idiom in Rust: each time the last eselement of a block
is an expression, it is returned as a value.

Please note that these expressions are not followed by a semicolon.

* Adding nodes to our tree
Some times we might want to add new branches to our tree after we built it.

An example is to create a binary tree for sorting: we first start with a single
value in our root node:

#+begin_src dot :file images/post013_rust_sort_tree_0.png :exports results

digraph {
   rankdir = BT;
   subgraph {
        root [label=<Root<br/>content=5>, shape="box"];
   }
}
#+end_src

#+RESULTS:
[[file:images/post013_rust_sort_tree_0.png]]

as values are collected they will be eventually added to the tree: left node will have a value which is less than the parent, right node a value greater than the parent.

#+begin_src dot :file images/post013_rust_sort_tree_1.png :exports results
digraph {
   rankdir = BT;
   subgraph {
        root [label=<R<br/>content=5>, shape="box"];
        left [label=<R.left<br/>content=2>, shape="box"];
        right [label=<R.right<br/>content=6>, shape="box"];
        left_right [label=<R.left.right<br/>content=4>, shape="box"];
        root -> left
        root -> right
        left -> left_right
        {rank = same; left; right;}
        {rank = same; left_right;}
   }
}
#+end_src

#+RESULTS:
[[file:images/post013_rust_sort_tree_1.png]]

This requires quite a few Rust idioms
- we need to create a mutable root in order to send mutable references to a
  function, this is needed to add new branches to our initial root
- we need to access each node and possibly understand if it has any chidren:
  this will be done by using a pattern match on the ~Option~ enum.
- we need to access some children node as a mutable reference; using the ~ref
  mut~ signature in the pattern match we can achieve this

#+begin_src rust
fn main() {
    //this is the root node
    let mut test = BTree1{ left: None, right: None, content: 5 };
    add_element(& mut test, 2); // this will add a left branch
    add_element(& mut test, 4); // this will add a right branch on the left branch
    add_element(& mut test, 5); // this will be ignored
    add_element(& mut test, 6); // this will add a rigth branch
    println!("Hello, world! {:?}", test);
}

fn add_element(node: & mut BTree1, value: i32){
    if node.content == value{
        // if the value is already in the tree do nothing
        return;
    } else if node.content < value {
        // check the left side for smaller values
        match node.left {
            None => {
                node.left = Some(Box::new(
                    BTree1 { left: None, right :None, content: value}
                ));
            }
            // a tricky part: we need to tell the compiler to return a
            // mutable reference from this pattern match otherwise it
            // may try to move the ownership of the data (which we don't want)
            Some(ref mut subnode) => {
                add_element(subnode, value);
            }
        }
    } else {
        match node.right {
            None => {
                node.left = Some(Box::new(
                    BTree1 { left: None, right :None, content: value}
                ));
            }
            Some(ref mut subnode) => {
                add_element(subnode, value);
            }
        }
    }
}
#+end_src
* Exploring the tree
we can extract the content of our tree in a way that shows it in order:
1. enter a node
2. if it has a left node enter the left node (back to point 1)
3. print the content of the current node
4. if it has a right node enter the right node (back to point 1)
5. return to the parent node

this sequence is called depth-first traversal of our binary tree.
